name: Fetch Runtime Errors

on:
  push:
    branches: [main]
  workflow_dispatch:
    # Allow manual triggering from the Actions tab.

permissions:
  contents: write
  issues: write

jobs:
  fetch-errors:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Fetch full history so we can push cleanly.
          fetch-depth: 0

      - name: Fetch critical errors and create/update GitHub issues
        env:
          VERCEL_ERRORS_API_KEY: ${{ secrets.VERCEL_ERRORS_API_KEY }}
          ERRORS_ENDPOINT: https://flit-olive.vercel.app/api/errors
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          # Ensure logs directory exists.
          mkdir -p logs

          # ---------------------------------------------------------------
          # 1. Fetch critical errors from Vercel endpoint
          # ---------------------------------------------------------------
          HTTP_CODE=$(curl -s -o /tmp/errors_response.json -w "%{http_code}" \
            -H "X-API-Key: ${VERCEL_ERRORS_API_KEY}" \
            "${ERRORS_ENDPOINT}?severity=critical&limit=100" \
          ) || {
            echo "::warning::curl failed to connect to errors endpoint"
            exit 0
          }

          echo "Endpoint returned HTTP ${HTTP_CODE}"

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::warning::Errors endpoint returned HTTP ${HTTP_CODE}"
            cat /tmp/errors_response.json 2>/dev/null || true
            exit 0
          fi

          RESPONSE=$(cat /tmp/errors_response.json)
          COUNT=$(echo "$RESPONSE" | jq -r '.count // 0')
          echo "Fetched ${COUNT} critical error(s)"

          if [ "$COUNT" -eq 0 ]; then
            echo "No critical errors to process."
            exit 0
          fi

          # Extract errors array into a file for processing.
          echo "$RESPONSE" | jq -c '.errors[]' > /tmp/critical_errors.jsonl

          # ---------------------------------------------------------------
          # 2. Process each critical error: deduplicate via GitHub Issues
          # ---------------------------------------------------------------
          ISSUES_CREATED=0
          ISSUES_UPDATED=0

          while IFS= read -r error_json; do
            # Extract fields from the error JSON.
            ERROR_MSG=$(echo "$error_json" | jq -r '.error // "Unknown error"')
            PLATFORM=$(echo "$error_json" | jq -r '.platform // "unknown"')
            STACK_TRACE=$(echo "$error_json" | jq -r '.stackTrace // "No stack trace"')
            DEVICE_INFO=$(echo "$error_json" | jq -r '.deviceInfo // "unknown"')
            APP_VERSION=$(echo "$error_json" | jq -r '.appVersion // "unknown"')
            TIMESTAMP=$(echo "$error_json" | jq -r '.timestamp // "unknown"')
            SEVERITY=$(echo "$error_json" | jq -r '.severity // "critical"')
            CONTEXT=$(echo "$error_json" | jq -r '.context // {} | to_entries | map("\(.key): \(.value)") | join(", ")')

            # a. Create a fingerprint: first 100 chars of error + platform.
            FINGERPRINT_RAW="${ERROR_MSG:0:100}|${PLATFORM}"
            FINGERPRINT=$(echo -n "$FINGERPRINT_RAW" | md5sum | cut -d' ' -f1)

            # b. Create a search-friendly tag for the issue body.
            FINGERPRINT_TAG="[fingerprint:${FINGERPRINT}]"

            # c. Search existing open issues for this fingerprint.
            EXISTING_ISSUE=$(gh issue list \
              --state open \
              --label "auto-triage" \
              --search "${FINGERPRINT_TAG}" \
              --json number,title \
              --jq '.[0].number // empty' \
              2>/dev/null || true)

            if [ -n "$EXISTING_ISSUE" ]; then
              # d. Duplicate found: add a comment with occurrence + timestamp.
              {
                echo "## Recurring Occurrence"
                echo ""
                echo "**Timestamp:** ${TIMESTAMP}"
                echo "**Platform:** ${PLATFORM}"
                echo "**Device:** ${DEVICE_INFO}"
                echo "**App Version:** ${APP_VERSION}"
                echo "**Context:** ${CONTEXT}"
                echo ""
                echo '```'
                echo "${ERROR_MSG}"
                echo '```'
                echo ""
                echo "_This error has been reported again. Auto-detected by error pipeline._"
              } > /tmp/comment_body.md

              gh issue comment "$EXISTING_ISSUE" --body-file /tmp/comment_body.md
              echo "Updated existing issue #${EXISTING_ISSUE} with new occurrence"
              ISSUES_UPDATED=$((ISSUES_UPDATED + 1))
            else
              # e. New error: create a GitHub issue.
              ISSUE_TITLE="${ERROR_MSG:0:80}"

              {
                echo "## Critical Runtime Error"
                echo ""
                echo "${FINGERPRINT_TAG}"
                echo ""
                echo "### Error"
                echo '```'
                echo "${ERROR_MSG}"
                echo '```'
                echo ""
                echo "### Stack Trace"
                echo '```'
                echo "${STACK_TRACE}"
                echo '```'
                echo ""
                echo "### Environment"
                echo "| Field | Value |"
                echo "|---|---|"
                echo "| **Platform** | ${PLATFORM} |"
                echo "| **Device** | ${DEVICE_INFO} |"
                echo "| **App Version** | ${APP_VERSION} |"
                echo "| **Severity** | ${SEVERITY} |"
                echo "| **Timestamp** | ${TIMESTAMP} |"
                echo ""
                echo "### Context"
                echo "${CONTEXT:-No additional context}"
                echo ""
                echo "---"
                echo "_Auto-created by error telemetry pipeline._"
              } > /tmp/issue_body.md

              gh issue create \
                --title "$ISSUE_TITLE" \
                --body-file /tmp/issue_body.md \
                --label "bug,critical,auto-triage"

              echo "Created new issue: ${ISSUE_TITLE}"
              ISSUES_CREATED=$((ISSUES_CREATED + 1))
            fi
          done < /tmp/critical_errors.jsonl

          echo "Summary: ${ISSUES_CREATED} issues created, ${ISSUES_UPDATED} issues updated"

          # Clean up temp files.
          rm -f /tmp/critical_errors.jsonl /tmp/comment_body.md /tmp/issue_body.md /tmp/errors_response.json

      - name: Purge logs and commit
        run: |
          set -euo pipefail

          # Ensure logs directory exists.
          mkdir -p logs

          # Purge logs completely â€” write empty file.
          echo -n "" > logs/runtime-errors.jsonl

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add logs/runtime-errors.jsonl

          # Only commit if there are staged changes.
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M UTC")
          git commit -m "chore: process critical errors and purge logs (${TIMESTAMP})"
          git push
